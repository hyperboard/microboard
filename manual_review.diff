diff a/src/Events/EventsOperations.ts b/src/Events/EventsOperations.ts	(rejected hunks)
@@ -21,20 +21,28 @@ interface Undo {
 }
 
 interface Redo {
 	class: "Events";
 	method: "redo";
 	eventId: string;
 }
 
 export type EventsOperation = Undo | Redo;
 
+export interface BaseOperation<T extends Record<string, unknown> = {}> {
+	class: string;
+	item: string[];
+	method: string;
+	newData: T;
+	prevData: T;
+}
+
 export type ItemOperation =
 	| LinkToOperation
 	| TransformationOperation
 	| ShapeOperation
 	| StickerOperation
 	| RichTextOperation
 	| ConnectorOperation
 	| DrawingOperation
 	| FrameOperation
 	| PlaceholderOperation
diff a/src/Events/Command.ts b/src/Events/Command.ts	(rejected hunks)
@@ -1,46 +1,251 @@
 import { Board } from "Board";
 import { ShapeCommand } from "Items/Shape/ShapeCommand";
 import { BoardCommand } from "../BoardCommand";
 import { TransformationCommand } from "../Items/Transformation/TransformationCommand";
 import {
 	RichTextCommand,
 	RichTextGroupCommand,
 } from "../Items/RichText/RichTextCommand";
 import { EventsCommand } from "./EventsCommand";
 import { ConnectorCommand } from "Items/Connector/ConnectorCommand";
-import { Operation } from "./EventsOperations";
+import { BaseOperation, ItemOperation, Operation } from "./EventsOperations";
 import { DrawingCommand } from "Items/Drawing/DrawingCommand";
 import { StickerCommand } from "../Items/Sticker/StickerCommand";
-import { Connector, Frame, Item, RichText, Shape } from "Items";
+import {
+	Connector,
+	ConnectorOperation,
+	Frame,
+	Item,
+	RichText,
+	RichTextOperation,
+	Shape,
+	TransformationOperation,
+} from "Items";
 import { Drawing } from "Items/Drawing";
 import { Sticker } from "Items/Sticker";
 import { FrameCommand } from "Items/Frame/FrameCommand";
-import { Comment, CommentCommand } from "../Items/Comment";
+import { Comment, CommentCommand, CommentOperation } from "../Items/Comment";
 import { LinkToCommand } from "../Items/LinkTo/LinkToCommand";
 import { GroupCommand } from "Items/Group/GroupCommand";
 import { Group } from "Items/Group";
 import { PlaceholderCommand } from "Items/Placeholder/PlaceholderCommand";
 import { Placeholder } from "Items/Placeholder";
 import { ImageCommand } from "Items/Image/ImageCommand";
 import { ImageItem } from "Items/Image";
 import { VideoCommand } from "Items/Video/VideoCommand";
 import { VideoItem } from "Items/Video/Video";
 import { AudioCommand } from "Items/Audio/AudioCommand";
 import { AudioItem } from "Items/Audio/Audio";
+import { ShapeOperation } from "Items/Shape/ShapeOperation";
+import { DrawingOperation } from "Items/Drawing/DrawingOperation";
+import { StickerOperation } from "Items/Sticker/StickerOperation";
+import { FrameOperation } from "Items/Frame/FrameOperation";
+import { PlaceholderOperation } from "Items/Placeholder/PlaceholderOperation";
+import { GroupOperation } from "Items/Group/GroupOperation";
+import { LinkToOperation } from "Items/LinkTo/LinkToOperation";
+import { BaseItem } from "Items/BaseItem/BaseItem";
+import { mapItemsByOperation } from "Items/ItemsCommandUtils";
 
 export interface Command {
 	apply(): void;
 
 	revert(): void;
 }
 
+export class BaseCommand {
+	private reverse: { item: BaseItem; operation: BaseOperation }[];
+
+	constructor(
+		public items: BaseItem[],
+		public operation: BaseOperation,
+	) {
+		this.reverse = this.getReverse();
+	}
+
+	merge(op: BaseOperation): this {
+		this.operation = op;
+		return this;
+	}
+
+	apply(): void {
+		for (const item of this.items) {
+			item.apply(this.operation as Operation);
+		}
+	}
+
+	revert(): void {
+		for (const { item, operation } of this.reverse) {
+			item.apply(operation as Operation);
+		}
+	}
+
+	getReverse(): { item: BaseItem; operation: BaseOperation }[] {
+		const items = this.items;
+
+		return mapItemsByOperation(items, item => {
+			const op = this.operation;
+			return {
+				...op,
+				newData: op.prevData,
+			};
+		});
+	}
+}
+
+export interface ItemCommandFactory {
+	(
+		items: Item[],
+		operation: ItemOperation | TransformationOperation,
+		board?: Board,
+	): Command;
+}
+
+export const itemCommandFactories: Record<string, ItemCommandFactory> = {
+	Sticker: createStickerCommand,
+	Shape: createShapeCommand,
+	RichText: createRichTextCommand,
+	Connector: createConnectorCommand,
+	Image: createImageCommand,
+	Drawing: createDrawingCommand,
+	Frame: createFrameCommand,
+	Placeholder: createPlaceholderCommand,
+	Comment: createCommentCommand,
+	Group: createGroupCommand,
+	Video: createVideoCommand,
+	Audio: createAudioCommand,
+	Transformation: createTransformationCommand,
+	LinkTo: createLinkToCommand,
+};
+
+function createConnectorCommand(items: Item[], operation: ItemOperation) {
+	return new ConnectorCommand(
+		items.filter(
+			(item): item is Connector => item.itemType === "Connector",
+		),
+		operation as ConnectorOperation,
+	);
+}
+
+function createShapeCommand(items: Item[], operation: ItemOperation) {
+	return new ShapeCommand(
+		items.filter((item): item is Shape => item.itemType === "Shape"),
+		operation as ShapeOperation,
+	);
+}
+
+function createDrawingCommand(items: Item[], operation: ItemOperation) {
+	return new DrawingCommand(
+		items.filter((item): item is Drawing => item.itemType === "Drawing"),
+		operation as DrawingOperation,
+	);
+}
+
+function createCommentCommand(items: Item[], operation: ItemOperation) {
+	return new CommentCommand(
+		items.filter((item): item is Comment => item.itemType === "Comment"),
+		operation as CommentOperation,
+	);
+}
+
+function createStickerCommand(items: Item[], operation: ItemOperation) {
+	return new StickerCommand(
+		items.filter((item): item is Sticker => item.itemType === "Sticker"),
+		operation as StickerOperation,
+	);
+}
+
+function createFrameCommand(items: Item[], operation: ItemOperation) {
+	return new FrameCommand(
+		items.filter((item): item is Frame => item.itemType === "Frame"),
+		operation as FrameOperation,
+	);
+}
+
+function createPlaceholderCommand(items: Item[], operation: ItemOperation) {
+	return new PlaceholderCommand(
+		items.filter(
+			(item): item is Placeholder => item.itemType === "Placeholder",
+		),
+		operation as PlaceholderOperation,
+	);
+}
+
+function createGroupCommand(items: Item[], operation: ItemOperation) {
+	return new GroupCommand(
+		items.filter((item): item is Group => item.itemType === "Group"),
+		operation as GroupOperation,
+	);
+}
+
+function createImageCommand(items: Item[], operation: ItemOperation) {
+	return new ImageCommand(
+		items.filter((item): item is ImageItem => item.itemType === "Image"),
+		operation,
+	);
+}
+
+function createVideoCommand(items: Item[], operation: ItemOperation) {
+	return new VideoCommand(
+		items.filter((item): item is VideoItem => item.itemType === "Video"),
+		operation,
+	);
+}
+
+function createAudioCommand(items: Item[], operation: ItemOperation) {
+	return new AudioCommand(
+		items.filter((item): item is AudioItem => item.itemType === "Audio"),
+		operation,
+	);
+}
+
+function createRichTextCommand(
+	items: Item[],
+	operation: ItemOperation,
+	board?: Board,
+) {
+	if (!board) {
+		return new NoOpCommand(`Board not found`);
+	}
+	if (operation.method === "groupEdit") {
+		const texts: RichText[] = [];
+		for (const { item } of operation.itemsOps) {
+			const found = board.items.findById(item);
+			const text = found?.getRichText();
+			if (text) {
+				texts.push(text);
+			}
+		}
+		return new RichTextGroupCommand(texts, operation);
+	} else {
+		return new RichTextCommand(
+			board,
+			items.map(item => item.getId()),
+			operation as RichTextOperation,
+		);
+	}
+}
+
+function createTransformationCommand(items: Item[], operation: ItemOperation) {
+	return new TransformationCommand(
+		items.map(item => item.transformation),
+		operation as TransformationOperation,
+	);
+}
+
+function createLinkToCommand(items: Item[], operation: ItemOperation) {
+	return new LinkToCommand(
+		items.map(item => item.linkTo),
+		operation as LinkToOperation,
+	);
+}
+
 export function createCommand(board: Board, operation: Operation): Command {
 	// TODO API
 	try {
 		switch (operation.class) {
 			case "Events": {
 				const events = board.events;
 				if (!events) {
 					return new NoOpCommand("Board Has No Events Record");
 				}
 				return new EventsCommand(board, operation);
@@ -77,137 +282,76 @@ export function createCommand(board: Board, operation: Operation): Command {
 							console.warn(
 								`Item with ID ${item} is not of operation type: ${itemType}.`,
 							);
 							return false;
 						}
 						return true;
 					});
 
 				switch (operation.class) {
 					case "Connector":
-						return new ConnectorCommand(
-							items.filter(
-								(item): item is Connector =>
-									item.itemType === "Connector",
-							),
+						return itemCommandFactories["Connector"](
+							items,
 							operation,
 						);
 					case "Shape":
-						return new ShapeCommand(
-							items.filter(
-								(item): item is Shape =>
-									item.itemType === "Shape",
-							),
-							operation,
-						);
+						return itemCommandFactories["Shape"](items, operation);
 					case "Drawing":
-						return new DrawingCommand(
-							items.filter(
-								(item): item is Drawing =>
-									item.itemType === "Drawing",
-							),
+						return itemCommandFactories["Drawing"](
+							items,
 							operation,
 						);
 					case "Comment":
-						return new CommentCommand(
-							items.filter(
-								(item): item is Comment =>
-									item.itemType === "Comment",
-							),
+						return itemCommandFactories["Comment"](
+							items,
 							operation,
 						);
 					case "Sticker":
-						return new StickerCommand(
-							items.filter(
-								(item): item is Sticker =>
-									item.itemType === "Sticker",
-							),
+						return itemCommandFactories["Sticker"](
+							items,
 							operation,
 						);
 					case "LinkTo":
-						return new LinkToCommand(
-							items.map(item => item.linkTo),
-							operation,
-						);
+						return itemCommandFactories["LinkTo"](items, operation);
 					case "Transformation":
-						return new TransformationCommand(
-							items.map(item => item.transformation),
+						return itemCommandFactories["Transformation"](
+							items,
 							operation,
 						);
 					case "RichText":
-						if (operation.method === "groupEdit") {
-							const texts: RichText[] = [];
-							for (const { item } of operation.itemsOps) {
-								const found = board.items.findById(item);
-								const text = found?.getRichText();
-								if (text) {
-									texts.push(text);
-								}
-							}
-							return new RichTextGroupCommand(texts, operation);
-						} else {
-							return new RichTextCommand(
-								board,
-								items.map(item => item.getId()),
-								operation,
-							);
-						}
-					case "Frame":
-						return new FrameCommand(
-							items.filter(
-								(item): item is Frame =>
-									item.itemType === "Frame",
-							),
+						return itemCommandFactories["RichText"](
+							items,
 							operation,
+							board,
 						);
+					case "Frame":
+						return itemCommandFactories["Frame"](items, operation);
 					case "Placeholder":
-						return new PlaceholderCommand(
-							items.filter(
-								(item): item is Placeholder =>
-									item.itemType === "Placeholder",
-							),
+						return itemCommandFactories["Placeholder"](
+							items,
 							operation,
 						);
 					case "Group":
-						return new GroupCommand(
-							items.filter(
-								(item): item is Group =>
-									item.itemType === "Group",
-							),
-							operation,
-						);
+						return itemCommandFactories["Group"](items, operation);
 					case "Image":
-						return new ImageCommand(
-							items.filter(
-								(item): item is ImageItem =>
-									item.itemType === "Image",
-							),
-							operation,
-						);
+						return itemCommandFactories["Image"](items, operation);
 					case "Video":
-						return new VideoCommand(
-							items.filter(
-								(item): item is VideoItem =>
-									item.itemType === "Video",
-							),
-							operation,
-						);
+						return itemCommandFactories["Video"](items, operation);
 					case "Audio":
-						return new AudioCommand(
-							items.filter(
-								(item): item is AudioItem =>
-									item.itemType === "Audio",
-							),
-							operation,
-						);
+						return itemCommandFactories["Audio"](items, operation);
 					default:
-						return new NoOpCommand(`Unsupported command type`);
+						const commandFactory =
+							itemCommandFactories[operation.class];
+						if (!commandFactory) {
+							return new NoOpCommand(`Unsupported command type`);
+						}
+						return commandFactory(items, operation, board);
 				}
 			}
 		}
 	} catch (error) {
 		if (error instanceof Error) {
 			return new NoOpCommand(error.message);
 		} else {
 			return new NoOpCommand(`An unknown error occurred: ${error}`);
 		}
 	}
diff a/src/itemFactories.ts b/src/itemFactories.ts	(rejected hunks)
@@ -1,11 +1,11 @@
-import type { RichTextData } from "./Items";
+import { registeredItemFactories, RichTextData } from "./Items";
 import {
 	Mbr,
 	Connector,
 	RichText,
 	Shape,
 	ShapeData,
 	ConnectorData,
 	Frame,
 	FrameData,
 	Point,
@@ -22,21 +22,21 @@ import { Group, GroupData } from "./Items/Group";
 import { Comment } from "./Items/Comment";
 import { AINode } from "Items/AINode/AINode";
 import { AINodeData } from "Items/AINode/AINodeData";
 import { VideoItem, VideoItemData } from "Items/Video/Video";
 import { AudioItem, AudioItemData } from "Items/Audio/Audio";
 
 interface ItemFactory {
 	(id: string, data: ItemData, board: Board): Item;
 }
 
-export type ItemFactories = Record<ItemType, ItemFactory>;
+export type ItemFactories = Record<string, ItemFactory>;
 export const itemFactories: ItemFactories = {
 	Sticker: createSticker,
 	Shape: createShape,
 	RichText: createRichText,
 	Connector: createConnector,
 	Image: createImage,
 	Drawing: createDrawing,
 	Frame: createFrame,
 	Placeholder: createPlaceholder,
 	Comment: createComment,
@@ -51,21 +51,21 @@ function createSticker(id: string, data: ItemData, board: Board): Sticker {
 		throw new Error("Invalid data for Sticker");
 	}
 	const sticker = new Sticker(board).setId(id).deserialize(data);
 	return sticker;
 }
 
 function createComment(id: string, data: ItemData, board: Board): Comment {
 	if (!isCommentData(data)) {
 		throw new Error("Invalid data for Comment");
 	}
-	const comment = new Comment(new Point(), board.events)
+	const comment = new Comment(board, new Point(), board.events)
 		.setId(id)
 		.deserialize(data);
 	return comment;
 }
 
 function createAINode(id: string, data: ItemData, board: Board): AINode {
 	if (!isAINodeData(data)) {
 		throw new Error("Invalid data for AINode");
 	}
 	const nodeData = data as AINodeData;
@@ -165,21 +165,21 @@ function createFrame(id: string, data: ItemData, board: Board): Frame {
 }
 
 function createPlaceholder(
 	id: string,
 	data: ItemData,
 	board: Board,
 ): Placeholder {
 	if (!isPlaceholderData(data)) {
 		throw new Error("Invalid data for Placeholder");
 	}
-	const placeholder = new Placeholder(board.events, data.miroData)
+	const placeholder = new Placeholder(board, board.events, data.miroData)
 		.setId(id)
 		.deserialize(data);
 
 	return placeholder;
 }
 
 function createGroup(id: string, data: ItemData, board: Board): Group {
 	if (!isGroupData(data)) {
 		throw new Error("Invalid data for Group");
 	}
diff a/src/Selection/Selection.ts b/src/Selection/Selection.ts	(rejected hunks)
@@ -23,21 +23,20 @@ import { ItemOp } from "Items/RichText/RichTextOperations";
 import { tempStorage } from "App/SessionStorage";
 import { Tool } from "Tools/Tool";
 import {
 	AINode,
 	CONTEXT_NODE_HIGHLIGHT_COLOR,
 } from "Items/AINode/AINode";
 import { BaseRange, BaseSelection, Editor } from "slate";
 import { CONNECTOR_COLOR } from "Items/Connector/Connector";
 import { safeRequestAnimationFrame } from "api/safeRequestAnimationFrame";
 import { deleteMedia, updateMediaUsage } from "Items/Image/ImageHelpers";
-import { getSlateSelectionRect } from "Items/RichText/getSlateSelectionRect";
 import { ReactEditor } from "slate-react";
 const { i18n } = conf;
 
 const defaultShapeData = new DefaultShapeData();
 
 export type SelectionContext =
 	| "SelectUnderPointer"
 	| "HoverUnderPointer"
 	| "EditUnderPointer"
 	| "EditTextUnderPointer"
diff a/src/Items/Placeholder/Placeholder.ts b/src/Items/Placeholder/Placeholder.ts	(rejected hunks)
@@ -5,51 +5,56 @@ import { ResizeType } from "Selection/Transformer/TransformerHelpers/getRe
 import { Subject } from "shared/Subject";
 import { GeometricNormal } from "../GeometricNormal";
 import { Line } from "../Line";
 import { Mbr } from "../Mbr";
 import { Path, Paths } from "../Path";
 import { Point } from "../Point";
 import { Transformation, Matrix, TransformationData } from "../Transformation";
 import { PlaceholderOperation } from "./PlaceholderOperation";
 import { PlaceholderCommand } from "./PlaceholderCommand";
 import { getResize } from "../../Selection/Transformer/TransformerHelpers/getResizeMatrix.ts";
+import { BaseItem } from "Items/BaseItem/BaseItem";
+import { Board } from "Board";
+import { DocumentFactory } from "api/DocumentFactory";
 
 const PlaceholderImg = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
 <path d="M5 11.1L7 9.1L12.5 14.6L16 11.1L19 14.1V5H5V11.1ZM4 3H20C20.2652 3 20.5196 3.10536 20.7071 3.29289C20.8946 3.48043 21 3.73478 21 4V20C21 20.2652 20.8946 20.5196 20.7071 20.7071C20.5196 20.8946 20.2652 21 20 21H4C3.73478 21 3.48043 20.8946 3.29289 20.7071C3.10536 20.5196 3 20.2652 3 20V4C3 3.73478 3.10536 3.48043 3.29289 3.29289C3.48043 3.10536 3.73478 3 4 3ZM15.5 10C15.1022 10 14.7206 9.84196 14.4393 9.56066C14.158 9.27936 14 8.89782 14 8.5C14 8.10218 14.158 7.72064 14.4393 7.43934C14.7206 7.15804 15.1022 7 15.5 7C15.8978 7 16.2794 7.15804 16.5607 7.43934C16.842 7.72064 17 8.10218 17 8.5C17 8.89782 16.842 9.27936 16.5607 9.56066C16.2794 9.84196 15.8978 10 15.5 10Z" fill="white" fill-opacity="0.6"/>
 </svg>`;
 
 export interface PlaceholderData {
 	readonly itemType: "Placeholder";
 	backgroundColor: string;
 	icon: string;
 	transformation: TransformationData;
 	miroData?: unknown;
 }
 
-export class Placeholder {
+export class Placeholder extends BaseItem {
 	readonly itemType = "Placeholder";
 	shapeType = "Rectangle";
 	parent = "Board";
 	readonly transformation: Transformation;
 	private path = Shapes[this.shapeType].path.copy();
 	private mbr = Shapes[this.shapeType].path.getMbr().copy();
 	readonly subject = new Subject<Placeholder>();
 	transformationRenderBlock?: boolean = undefined;
 	iconImage;
 
 	constructor(
+		board: Board,
 		private events?: Events,
 		private miroData?: unknown,
-		private id = "",
-		private backgroundColor = "#E5E5EA",
+		id = "",
+		public backgroundColor = "#E5E5EA",
 		private icon: string = PlaceholderImg?.toString() || "",
 	) {
+		super(board, id);
 		this.transformation = new Transformation(this.id, this.events);
 		this.transformation.subject.subscribe((_subject: Transformation) => {
 			this.transformPath();
 			this.updateMbr();
 			this.subject.publish(this);
 		});
 		this.updateMbr();
 		this.loadIconImage();
 	}
 
@@ -345,18 +350,22 @@ export class Placeholder {
 
 	render(context: DrawingContext): void {
 		if (this.transformationRenderBlock) {
 			return;
 		}
 
 		this.renderShadowShape(context);
 		this.renderIcon(context);
 	}
 
+	renderHTML(documentFactory: DocumentFactory): HTMLElement {
+		return documentFactory.createElement("div");
+	}
+
 	getLinkTo(): undefined {
 		return undefined;
 	}
 
 	getRichText(): null {
 		return null;
 	}
 }
diff a/src/Items/index.ts b/src/Items/index.ts	(rejected hunks)
@@ -12,10 +12,15 @@ export type { ConnectorOperation } from "./Connector";
 export type { RichTextData, RichTextOperation } from "./RichText";
 export { RichText } from "./RichText";
 export type { ShapeData } from "./Shape";
 export { Shape } from "./Shape";
 export { Frame } from "./Frame";
 export type { FrameData } from "./Frame";
 
 export type { Item, ItemType, ItemData } from "./Item";
 
 export { ItemsLocalCounter } from "./ItemsLocalCounter";
+
+export { registerItem } from "./RegisterItem.ts";
+
+export { Star } from "./Examples/Star";
+export { Counter } from "./Examples/Counter";
diff a/src/Items/Frame/Frame.ts b/src/Items/Frame/Frame.ts	(rejected hunks)
@@ -2,21 +2,20 @@ import {
 	Mbr,
 	Line,
 	Point,
 	Transformation,
 	Path,
 	Paths,
 	Item,
 	RichText,
 	Matrix,
 } from "..";
-import { Geometry } from "../Geometry";
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
 import { Operation } from "Events";
 import { FrameOperation } from "./FrameOperation";
 import { Frames, FrameType } from "./Basic";
 import { GeometricNormal } from "../GeometricNormal";
 import { FrameCommand } from "./FrameCommand";
 import {
 	getProportionalResize,
 	getResize,
@@ -26,50 +25,52 @@ import { Board } from "Board";
 import {
 	exportBoardSnapshot,
 	SnapshotInfo,
 } from "Tools/ExportSnapshot/exportBoardSnapshot";
 import { LinkTo } from "../LinkTo/LinkTo";
 import { translateElementBy } from "HTMLRender";
 import { DefaultFrameData, FRAME_TITLE_COLOR, FrameData } from "./FrameData";
 import { DocumentFactory } from "api/DocumentFactory";
 
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 const defaultFrameData = new DefaultFrameData();
 
-export class Frame implements Geometry {
+export class Frame extends BaseItem {
 	readonly itemType = "Frame";
 	parent = "Board";
 	readonly transformation: Transformation;
 	readonly subject = new Subject<Frame>();
 	private textContainer: Mbr;
 	private path: Path;
 	private children: string[] = [];
 	private mbr: Mbr = new Mbr();
 	readonly linkTo: LinkTo;
 	readonly text: RichText;
 	private canChangeRatio = true;
 	newShape: FrameType | null = null;
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		private getItemById: (id: string) => Item | undefined,
-		private id = "",
+		id = "",
 		private name = "",
 		private shapeType = defaultFrameData.shapeType,
-		private backgroundColor = defaultFrameData.backgroundColor,
-		private backgroundOpacity = defaultFrameData.backgroundOpacity,
-		private borderColor = defaultFrameData.borderColor,
-		private borderOpacity = defaultFrameData.borderOpacity,
-		private borderStyle = defaultFrameData.borderStyle,
-		private borderWidth = defaultFrameData.borderWidth,
+		public backgroundColor = defaultFrameData.backgroundColor,
+		public backgroundOpacity = defaultFrameData.backgroundOpacity,
+		public borderColor = defaultFrameData.borderColor,
+		public borderOpacity = defaultFrameData.borderOpacity,
+		public borderStyle = defaultFrameData.borderStyle,
+		public borderWidth = defaultFrameData.borderWidth,
 	) {
+		super(board, id);
 		this.textContainer = Frames[this.shapeType].textBounds.copy();
 		this.path = Frames[this.shapeType].path.copy();
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 
 		this.text = new RichText(
 			board,
 			this.textContainer,
 			this.id,
 			this.transformation,
diff a/src/Items/Connector/Connector.ts b/src/Items/Connector/Connector.ts	(rejected hunks)
@@ -26,20 +26,21 @@ import { getStartPointer, getEndPointer } from "./Pointers/index";
 import { ConnectorPointerStyle, Pointer } from "./Pointers/Pointers";
 import { LinkTo } from "../LinkTo/LinkTo";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 } from "HTMLRender";
 import { DocumentFactory } from "api/DocumentFactory";
 import { ConnectorAnchorColors } from "./types";
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 const { i18n } = conf;
 
 export const ConnectorLineStyles = [
 	"straight",
 	"curved",
 	"orthogonal",
 ] as const;
 
 export type ConnectorLineStyle = (typeof ConnectorLineStyles)[number];
 
@@ -59,49 +60,50 @@ export const CONNECTOR_ANCHOR_COLOR: ConnectorAnchorColors = {
 	snapBackground: "rgba(0,0,0,0)",
 	anchorBorder: "rgb(147, 175, 246)",
 	anchorBackground: "rgb(255, 255, 255)",
 	anchorHighlight: "rgb(255, 255, 255)",
 	pointBorder: "rgb(147, 175, 246)",
 	pointBackground: "rgb(147, 175, 246)",
 };
 
 export const CONNECTOR_ANCHOR_TYPE = "rect";
 export const CONNECTOR_LINE_CAP = "round";
-export class Connector {
+export class Connector extends BaseItem {
 	readonly itemType = "Connector";
 	parent = "Board";
-	private id = "";
 	readonly transformation: Transformation;
 	private middlePoint: ControlPoint | null = new BoardPoint();
 	private lineColor: string;
 	readonly linkTo: LinkTo;
 	private lineWidth: ConnectionLineWidth;
-	private borderStyle: BorderStyle;
+	borderStyle: BorderStyle;
 	readonly subject = new Subject<Connector>();
 	lines = new Path([new Line(new Point(), new Point())]);
 	startPointer: Pointer;
 	endPointer: Pointer;
 	animationFrameId?: number;
 	readonly text: RichText;
 	transformationRenderBlock?: boolean = undefined;
 	private optionalFindItemFn?: FindItemFn;
 	constructor(
-		private board: Board,
+		board: Board,
 		private startPoint: ControlPoint = new BoardPoint(),
 		private endPoint: ControlPoint = new BoardPoint(),
 		private lineStyle: ConnectorLineStyle = "straight",
 		private startPointerStyle: ConnectorPointerStyle = "None",
 		private endPointerStyle: ConnectorPointerStyle = DEFAULT_END_POINTER,
 		lineColor?: string,
 		lineWidth?: ConnectionLineWidth,
 		strokeStyle?: BorderStyle,
+		id = "",
 	) {
+		super(board, id);
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 		this.lineColor = lineColor ?? CONNECTOR_COLOR;
 		this.lineWidth = lineWidth ?? CONNECTOR_LINE_WIDTH;
 		this.borderStyle = strokeStyle ?? CONNECTOR_BORDER_STYLE;
 		this.text = new RichText(
 			board,
 			this.getMbr(),
 			this.id,
 			new Transformation(),
diff a/src/Items/Sticker/Sticker.ts b/src/Items/Sticker/Sticker.ts	(rejected hunks)
@@ -22,20 +22,21 @@ import { LinkTo } from "../LinkTo/LinkTo";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender";
 import { SessionStorage } from "App/SessionStorage";
 import { Board } from "Board";
 import { DocumentFactory } from "api/DocumentFactory";
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export const stickerColors = {
 	Purple: "rgb(233, 208, 255)",
 	Pink: "rgb(255, 209, 211)",
 	"Sky Blue": "rgb(206, 228, 255)",
 	Blue: "rgb(205, 250, 255)",
 	Green: "rgb(203, 232, 150)",
 	"Light Green": "rgb(180, 241, 198)",
 	Orange: "rgb(255, 180, 126)",
 	Yellow: "rgb(255, 235, 163)",
@@ -67,36 +68,37 @@ export const StickerShape = {
 		new Point(width / 2, height),
 		new Point(0, height / 2),
 	],
 	DEFAULTS: [width, height],
 };
 
 const defaultStickerData = new StickerData();
 const _hypotenuse = Math.sqrt(height * height + width * width);
 const _relation = width / height;
 
-export class Sticker implements Geometry {
+export class Sticker extends BaseItem {
 	parent = "Board";
 	readonly itemType = "Sticker";
 	readonly transformation: Transformation;
 	readonly linkTo: LinkTo;
 	private stickerPath = StickerShape.stickerPath.copy();
 	private textContainer = StickerShape.textBounds.copy();
 	text: RichText;
 	readonly subject = new Subject<Sticker>();
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
-		private id = "",
-		private backgroundColor = defaultStickerData.backgroundColor,
+		board: Board,
+		id = "",
+		public backgroundColor = defaultStickerData.backgroundColor,
 	) {
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.text = new RichText(
 			board,
 			this.textContainer,
 			this.id,
 			this.transformation,
 			this.linkTo,
 			"\u00A0",
 			false,
