diff a/src/Events/EventsOperations.ts b/src/Events/EventsOperations.ts	(rejected hunks)
@@ -21,20 +21,28 @@ interface Undo {
 }
 
 interface Redo {
 	class: "Events";
 	method: "redo";
 	eventId: string;
 }
 
 export type EventsOperation = Undo | Redo;
 
+export interface BaseOperation<T extends Record<string, unknown> = {}> {
+	class: string;
+	item: string[];
+	method: string;
+	newData: T;
+	prevData: T;
+}
+
 export type ItemOperation =
 	| LinkToOperation
 	| TransformationOperation
 	| ShapeOperation
 	| StickerOperation
 	| RichTextOperation
 	| ConnectorOperation
 	| DrawingOperation
 	| FrameOperation
 	| PlaceholderOperation
diff a/src/Events/Command.ts b/src/Events/Command.ts	(rejected hunks)
@@ -1,46 +1,251 @@
 import { Board } from "Board";
 import { ShapeCommand } from "Items/Shape/ShapeCommand";
 import { BoardCommand } from "../BoardCommand";
 import { TransformationCommand } from "../Items/Transformation/TransformationCommand";
 import {
 	RichTextCommand,
 	RichTextGroupCommand,
 } from "../Items/RichText/RichTextCommand";
 import { EventsCommand } from "./EventsCommand";
 import { ConnectorCommand } from "Items/Connector/ConnectorCommand";
-import { Operation } from "./EventsOperations";
+import { BaseOperation, ItemOperation, Operation } from "./EventsOperations";
 import { DrawingCommand } from "Items/Drawing/DrawingCommand";
 import { StickerCommand } from "../Items/Sticker/StickerCommand";
-import { Connector, Frame, Item, RichText, Shape } from "Items";
+import {
+	Connector,
+	ConnectorOperation,
+	Frame,
+	Item,
+	RichText,
+	RichTextOperation,
+	Shape,
+	TransformationOperation,
+} from "Items";
 import { Drawing } from "Items/Drawing";
 import { Sticker } from "Items/Sticker";
 import { FrameCommand } from "Items/Frame/FrameCommand";
-import { Comment, CommentCommand } from "../Items/Comment";
+import { Comment, CommentCommand, CommentOperation } from "../Items/Comment";
 import { LinkToCommand } from "../Items/LinkTo/LinkToCommand";
 import { GroupCommand } from "Items/Group/GroupCommand";
 import { Group } from "Items/Group";
 import { PlaceholderCommand } from "Items/Placeholder/PlaceholderCommand";
 import { Placeholder } from "Items/Placeholder";
 import { ImageCommand } from "Items/Image/ImageCommand";
 import { ImageItem } from "Items/Image";
 import { VideoCommand } from "Items/Video/VideoCommand";
 import { VideoItem } from "Items/Video/Video";
 import { AudioCommand } from "Items/Audio/AudioCommand";
 import { AudioItem } from "Items/Audio/Audio";
+import { ShapeOperation } from "Items/Shape/ShapeOperation";
+import { DrawingOperation } from "Items/Drawing/DrawingOperation";
+import { StickerOperation } from "Items/Sticker/StickerOperation";
+import { FrameOperation } from "Items/Frame/FrameOperation";
+import { PlaceholderOperation } from "Items/Placeholder/PlaceholderOperation";
+import { GroupOperation } from "Items/Group/GroupOperation";
+import { LinkToOperation } from "Items/LinkTo/LinkToOperation";
+import { BaseItem } from "Items/BaseItem/BaseItem";
+import { mapItemsByOperation } from "Items/ItemsCommandUtils";
 
 export interface Command {
 	apply(): void;
 
 	revert(): void;
 }
 
+export class BaseCommand {
+	private reverse: { item: BaseItem; operation: BaseOperation }[];
+
+	constructor(
+		public items: BaseItem[],
+		public operation: BaseOperation,
+	) {
+		this.reverse = this.getReverse();
+	}
+
+	merge(op: BaseOperation): this {
+		this.operation = op;
+		return this;
+	}
+
+	apply(): void {
+		for (const item of this.items) {
+			item.apply(this.operation as Operation);
+		}
+	}
+
+	revert(): void {
+		for (const { item, operation } of this.reverse) {
+			item.apply(operation as Operation);
+		}
+	}
+
+	getReverse(): { item: BaseItem; operation: BaseOperation }[] {
+		const items = this.items;
+
+		return mapItemsByOperation(items, item => {
+			const op = this.operation;
+			return {
+				...op,
+				newData: op.prevData,
+			};
+		});
+	}
+}
+
+export interface ItemCommandFactory {
+	(
+		items: Item[],
+		operation: ItemOperation | TransformationOperation,
+		board?: Board,
+	): Command;
+}
+
+export const itemCommandFactories: Record<string, ItemCommandFactory> = {
+	Sticker: createStickerCommand,
+	Shape: createShapeCommand,
+	RichText: createRichTextCommand,
+	Connector: createConnectorCommand,
+	Image: createImageCommand,
+	Drawing: createDrawingCommand,
+	Frame: createFrameCommand,
+	Placeholder: createPlaceholderCommand,
+	Comment: createCommentCommand,
+	Group: createGroupCommand,
+	Video: createVideoCommand,
+	Audio: createAudioCommand,
+	Transformation: createTransformationCommand,
+	LinkTo: createLinkToCommand,
+};
+
+function createConnectorCommand(items: Item[], operation: ItemOperation) {
+	return new ConnectorCommand(
+		items.filter(
+			(item): item is Connector => item.itemType === "Connector",
+		),
+		operation as ConnectorOperation,
+	);
+}
+
+function createShapeCommand(items: Item[], operation: ItemOperation) {
+	return new ShapeCommand(
+		items.filter((item): item is Shape => item.itemType === "Shape"),
+		operation as ShapeOperation,
+	);
+}
+
+function createDrawingCommand(items: Item[], operation: ItemOperation) {
+	return new DrawingCommand(
+		items.filter((item): item is Drawing => item.itemType === "Drawing"),
+		operation as DrawingOperation,
+	);
+}
+
+function createCommentCommand(items: Item[], operation: ItemOperation) {
+	return new CommentCommand(
+		items.filter((item): item is Comment => item.itemType === "Comment"),
+		operation as CommentOperation,
+	);
+}
+
+function createStickerCommand(items: Item[], operation: ItemOperation) {
+	return new StickerCommand(
+		items.filter((item): item is Sticker => item.itemType === "Sticker"),
+		operation as StickerOperation,
+	);
+}
+
+function createFrameCommand(items: Item[], operation: ItemOperation) {
+	return new FrameCommand(
+		items.filter((item): item is Frame => item.itemType === "Frame"),
+		operation as FrameOperation,
+	);
+}
+
+function createPlaceholderCommand(items: Item[], operation: ItemOperation) {
+	return new PlaceholderCommand(
+		items.filter(
+			(item): item is Placeholder => item.itemType === "Placeholder",
+		),
+		operation as PlaceholderOperation,
+	);
+}
+
+function createGroupCommand(items: Item[], operation: ItemOperation) {
+	return new GroupCommand(
+		items.filter((item): item is Group => item.itemType === "Group"),
+		operation as GroupOperation,
+	);
+}
+
+function createImageCommand(items: Item[], operation: ItemOperation) {
+	return new ImageCommand(
+		items.filter((item): item is ImageItem => item.itemType === "Image"),
+		operation,
+	);
+}
+
+function createVideoCommand(items: Item[], operation: ItemOperation) {
+	return new VideoCommand(
+		items.filter((item): item is VideoItem => item.itemType === "Video"),
+		operation,
+	);
+}
+
+function createAudioCommand(items: Item[], operation: ItemOperation) {
+	return new AudioCommand(
+		items.filter((item): item is AudioItem => item.itemType === "Audio"),
+		operation,
+	);
+}
+
+function createRichTextCommand(
+	items: Item[],
+	operation: ItemOperation,
+	board?: Board,
+) {
+	if (!board) {
+		return new NoOpCommand(`Board not found`);
+	}
+	if (operation.method === "groupEdit") {
+		const texts: RichText[] = [];
+		for (const { item } of operation.itemsOps) {
+			const found = board.items.findById(item);
+			const text = found?.getRichText();
+			if (text) {
+				texts.push(text);
+			}
+		}
+		return new RichTextGroupCommand(texts, operation);
+	} else {
+		return new RichTextCommand(
+			board,
+			items.map(item => item.getId()),
+			operation as RichTextOperation,
+		);
+	}
+}
+
+function createTransformationCommand(items: Item[], operation: ItemOperation) {
+	return new TransformationCommand(
+		items.map(item => item.transformation),
+		operation as TransformationOperation,
+	);
+}
+
+function createLinkToCommand(items: Item[], operation: ItemOperation) {
+	return new LinkToCommand(
+		items.map(item => item.linkTo),
+		operation as LinkToOperation,
+	);
+}
+
 export function createCommand(board: Board, operation: Operation): Command {
 	// TODO API
 	try {
 		switch (operation.class) {
 			case "Events": {
 				const events = board.events;
 				if (!events) {
 					return new NoOpCommand("Board Has No Events Record");
 				}
 				return new EventsCommand(board, operation);
@@ -77,137 +282,76 @@ export function createCommand(board: Board, operation: Operation): Command {
 							console.warn(
 								`Item with ID ${item} is not of operation type: ${itemType}.`,
 							);
 							return false;
 						}
 						return true;
 					});
 
 				switch (operation.class) {
 					case "Connector":
-						return new ConnectorCommand(
-							items.filter(
-								(item): item is Connector =>
-									item.itemType === "Connector",
-							),
+						return itemCommandFactories["Connector"](
+							items,
 							operation,
 						);
 					case "Shape":
-						return new ShapeCommand(
-							items.filter(
-								(item): item is Shape =>
-									item.itemType === "Shape",
-							),
-							operation,
-						);
+						return itemCommandFactories["Shape"](items, operation);
 					case "Drawing":
-						return new DrawingCommand(
-							items.filter(
-								(item): item is Drawing =>
-									item.itemType === "Drawing",
-							),
+						return itemCommandFactories["Drawing"](
+							items,
 							operation,
 						);
 					case "Comment":
-						return new CommentCommand(
-							items.filter(
-								(item): item is Comment =>
-									item.itemType === "Comment",
-							),
+						return itemCommandFactories["Comment"](
+							items,
 							operation,
 						);
 					case "Sticker":
-						return new StickerCommand(
-							items.filter(
-								(item): item is Sticker =>
-									item.itemType === "Sticker",
-							),
+						return itemCommandFactories["Sticker"](
+							items,
 							operation,
 						);
 					case "LinkTo":
-						return new LinkToCommand(
-							items.map(item => item.linkTo),
-							operation,
-						);
+						return itemCommandFactories["LinkTo"](items, operation);
 					case "Transformation":
-						return new TransformationCommand(
-							items.map(item => item.transformation),
+						return itemCommandFactories["Transformation"](
+							items,
 							operation,
 						);
 					case "RichText":
-						if (operation.method === "groupEdit") {
-							const texts: RichText[] = [];
-							for (const { item } of operation.itemsOps) {
-								const found = board.items.findById(item);
-								const text = found?.getRichText();
-								if (text) {
-									texts.push(text);
-								}
-							}
-							return new RichTextGroupCommand(texts, operation);
-						} else {
-							return new RichTextCommand(
-								board,
-								items.map(item => item.getId()),
-								operation,
-							);
-						}
-					case "Frame":
-						return new FrameCommand(
-							items.filter(
-								(item): item is Frame =>
-									item.itemType === "Frame",
-							),
+						return itemCommandFactories["RichText"](
+							items,
 							operation,
+							board,
 						);
+					case "Frame":
+						return itemCommandFactories["Frame"](items, operation);
 					case "Placeholder":
-						return new PlaceholderCommand(
-							items.filter(
-								(item): item is Placeholder =>
-									item.itemType === "Placeholder",
-							),
+						return itemCommandFactories["Placeholder"](
+							items,
 							operation,
 						);
 					case "Group":
-						return new GroupCommand(
-							items.filter(
-								(item): item is Group =>
-									item.itemType === "Group",
-							),
-							operation,
-						);
+						return itemCommandFactories["Group"](items, operation);
 					case "Image":
-						return new ImageCommand(
-							items.filter(
-								(item): item is ImageItem =>
-									item.itemType === "Image",
-							),
-							operation,
-						);
+						return itemCommandFactories["Image"](items, operation);
 					case "Video":
-						return new VideoCommand(
-							items.filter(
-								(item): item is VideoItem =>
-									item.itemType === "Video",
-							),
-							operation,
-						);
+						return itemCommandFactories["Video"](items, operation);
 					case "Audio":
-						return new AudioCommand(
-							items.filter(
-								(item): item is AudioItem =>
-									item.itemType === "Audio",
-							),
-							operation,
-						);
+						return itemCommandFactories["Audio"](items, operation);
 					default:
-						return new NoOpCommand(`Unsupported command type`);
+						const commandFactory =
+							itemCommandFactories[operation.class];
+						if (!commandFactory) {
+							return new NoOpCommand(`Unsupported command type`);
+						}
+						return commandFactory(items, operation, board);
 				}
 			}
 		}
 	} catch (error) {
 		if (error instanceof Error) {
 			return new NoOpCommand(error.message);
 		} else {
 			return new NoOpCommand(`An unknown error occurred: ${error}`);
 		}
 	}
diff a/src/itemFactories.ts b/src/itemFactories.ts	(rejected hunks)
@@ -1,11 +1,11 @@
-import type { RichTextData } from "./Items";
+import { registeredItemFactories, RichTextData } from "./Items";
 import {
 	Mbr,
 	Connector,
 	RichText,
 	Shape,
 	ShapeData,
 	ConnectorData,
 	Frame,
 	FrameData,
 	Point,
@@ -22,21 +22,21 @@ import { Group, GroupData } from "./Items/Group";
 import { Comment } from "./Items/Comment";
 import { AINode } from "Items/AINode/AINode";
 import { AINodeData } from "Items/AINode/AINodeData";
 import { VideoItem, VideoItemData } from "Items/Video/Video";
 import { AudioItem, AudioItemData } from "Items/Audio/Audio";
 
 interface ItemFactory {
 	(id: string, data: ItemData, board: Board): Item;
 }
 
-export type ItemFactories = Record<ItemType, ItemFactory>;
+export type ItemFactories = Record<string, ItemFactory>;
 export const itemFactories: ItemFactories = {
 	Sticker: createSticker,
 	Shape: createShape,
 	RichText: createRichText,
 	Connector: createConnector,
 	Image: createImage,
 	Drawing: createDrawing,
 	Frame: createFrame,
 	Placeholder: createPlaceholder,
 	Comment: createComment,
@@ -51,21 +51,21 @@ function createSticker(id: string, data: ItemData, board: Board): Sticker {
 		throw new Error("Invalid data for Sticker");
 	}
 	const sticker = new Sticker(board).setId(id).deserialize(data);
 	return sticker;
 }
 
 function createComment(id: string, data: ItemData, board: Board): Comment {
 	if (!isCommentData(data)) {
 		throw new Error("Invalid data for Comment");
 	}
-	const comment = new Comment(new Point(), board.events)
+	const comment = new Comment(board, new Point(), board.events)
 		.setId(id)
 		.deserialize(data);
 	return comment;
 }
 
 function createAINode(id: string, data: ItemData, board: Board): AINode {
 	if (!isAINodeData(data)) {
 		throw new Error("Invalid data for AINode");
 	}
 	const nodeData = data as AINodeData;
@@ -165,21 +165,21 @@ function createFrame(id: string, data: ItemData, board: Board): Frame {
 }
 
 function createPlaceholder(
 	id: string,
 	data: ItemData,
 	board: Board,
 ): Placeholder {
 	if (!isPlaceholderData(data)) {
 		throw new Error("Invalid data for Placeholder");
 	}
-	const placeholder = new Placeholder(board.events, data.miroData)
+	const placeholder = new Placeholder(board, board.events, data.miroData)
 		.setId(id)
 		.deserialize(data);
 
 	return placeholder;
 }
 
 function createGroup(id: string, data: ItemData, board: Board): Group {
 	if (!isGroupData(data)) {
 		throw new Error("Invalid data for Group");
 	}
diff a/src/Selection/Selection.ts b/src/Selection/Selection.ts	(rejected hunks)
@@ -23,21 +23,20 @@ import { ItemOp } from "Items/RichText/RichTextOperations";
 import { tempStorage } from "App/SessionStorage";
 import { Tool } from "Tools/Tool";
 import {
 	AINode,
 	CONTEXT_NODE_HIGHLIGHT_COLOR,
 } from "Items/AINode/AINode";
 import { BaseRange, BaseSelection, Editor } from "slate";
 import { CONNECTOR_COLOR } from "Items/Connector/Connector";
 import { safeRequestAnimationFrame } from "api/safeRequestAnimationFrame";
 import { deleteMedia, updateMediaUsage } from "Items/Image/ImageHelpers";
-import { getSlateSelectionRect } from "Items/RichText/getSlateSelectionRect";
 import { ReactEditor } from "slate-react";
 const { i18n } = conf;
 
 const defaultShapeData = new DefaultShapeData();
 
 export type SelectionContext =
 	| "SelectUnderPointer"
 	| "HoverUnderPointer"
 	| "EditUnderPointer"
 	| "EditTextUnderPointer"
diff a/src/Items/Placeholder/Placeholder.ts b/src/Items/Placeholder/Placeholder.ts	(rejected hunks)
@@ -5,51 +5,56 @@ import { ResizeType } from "Selection/Transformer/TransformerHelpers/getRe
 import { Subject } from "shared/Subject";
 import { GeometricNormal } from "../GeometricNormal";
 import { Line } from "../Line";
 import { Mbr } from "../Mbr";
 import { Path, Paths } from "../Path";
 import { Point } from "../Point";
 import { Transformation, Matrix, TransformationData } from "../Transformation";
 import { PlaceholderOperation } from "./PlaceholderOperation";
 import { PlaceholderCommand } from "./PlaceholderCommand";
 import { getResize } from "../../Selection/Transformer/TransformerHelpers/getResizeMatrix.ts";
+import { BaseItem } from "Items/BaseItem/BaseItem";
+import { Board } from "Board";
+import { DocumentFactory } from "api/DocumentFactory";
 
 const PlaceholderImg = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
 <path d="M5 11.1L7 9.1L12.5 14.6L16 11.1L19 14.1V5H5V11.1ZM4 3H20C20.2652 3 20.5196 3.10536 20.7071 3.29289C20.8946 3.48043 21 3.73478 21 4V20C21 20.2652 20.8946 20.5196 20.7071 20.7071C20.5196 20.8946 20.2652 21 20 21H4C3.73478 21 3.48043 20.8946 3.29289 20.7071C3.10536 20.5196 3 20.2652 3 20V4C3 3.73478 3.10536 3.48043 3.29289 3.29289C3.48043 3.10536 3.73478 3 4 3ZM15.5 10C15.1022 10 14.7206 9.84196 14.4393 9.56066C14.158 9.27936 14 8.89782 14 8.5C14 8.10218 14.158 7.72064 14.4393 7.43934C14.7206 7.15804 15.1022 7 15.5 7C15.8978 7 16.2794 7.15804 16.5607 7.43934C16.842 7.72064 17 8.10218 17 8.5C17 8.89782 16.842 9.27936 16.5607 9.56066C16.2794 9.84196 15.8978 10 15.5 10Z" fill="white" fill-opacity="0.6"/>
 </svg>`;
 
 export interface PlaceholderData {
 	readonly itemType: "Placeholder";
 	backgroundColor: string;
 	icon: string;
 	transformation: TransformationData;
 	miroData?: unknown;
 }
 
-export class Placeholder {
+export class Placeholder extends BaseItem {
 	readonly itemType = "Placeholder";
 	shapeType = "Rectangle";
 	parent = "Board";
 	readonly transformation: Transformation;
 	private path = Shapes[this.shapeType].path.copy();
 	private mbr = Shapes[this.shapeType].path.getMbr().copy();
 	readonly subject = new Subject<Placeholder>();
 	transformationRenderBlock?: boolean = undefined;
 	iconImage;
 
 	constructor(
+		board: Board,
 		private events?: Events,
 		private miroData?: unknown,
-		private id = "",
-		private backgroundColor = "#E5E5EA",
+		id = "",
+		public backgroundColor = "#E5E5EA",
 		private icon: string = PlaceholderImg?.toString() || "",
 	) {
+		super(board, id);
 		this.transformation = new Transformation(this.id, this.events);
 		this.transformation.subject.subscribe((_subject: Transformation) => {
 			this.transformPath();
 			this.updateMbr();
 			this.subject.publish(this);
 		});
 		this.updateMbr();
 		this.loadIconImage();
 	}
 
@@ -345,18 +350,22 @@ export class Placeholder {
 
 	render(context: DrawingContext): void {
 		if (this.transformationRenderBlock) {
 			return;
 		}
 
 		this.renderShadowShape(context);
 		this.renderIcon(context);
 	}
 
+	renderHTML(documentFactory: DocumentFactory): HTMLElement {
+		return documentFactory.createElement("div");
+	}
+
 	getLinkTo(): undefined {
 		return undefined;
 	}
 
 	getRichText(): null {
 		return null;
 	}
 }
diff a/src/Items/index.ts b/src/Items/index.ts	(rejected hunks)
@@ -12,10 +12,15 @@ export type { ConnectorOperation } from "./Connector";
 export type { RichTextData, RichTextOperation } from "./RichText";
 export { RichText } from "./RichText";
 export type { ShapeData } from "./Shape";
 export { Shape } from "./Shape";
 export { Frame } from "./Frame";
 export type { FrameData } from "./Frame";
 
 export type { Item, ItemType, ItemData } from "./Item";
 
 export { ItemsLocalCounter } from "./ItemsLocalCounter";
+
+export { registerItem } from "./RegisterItem.ts";
+
+export { Star } from "./Examples/Star";
+export { Counter } from "./Examples/Counter";
diff a/src/Items/Frame/Frame.ts b/src/Items/Frame/Frame.ts	(rejected hunks)
@@ -2,21 +2,20 @@ import {
 	Mbr,
 	Line,
 	Point,
 	Transformation,
 	Path,
 	Paths,
 	Item,
 	RichText,
 	Matrix,
 } from "..";
-import { Geometry } from "../Geometry";
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
 import { Operation } from "Events";
 import { FrameOperation } from "./FrameOperation";
 import { Frames, FrameType } from "./Basic";
 import { GeometricNormal } from "../GeometricNormal";
 import { FrameCommand } from "./FrameCommand";
 import {
 	getProportionalResize,
 	getResize,
@@ -26,50 +25,52 @@ import { Board } from "Board";
 import {
 	exportBoardSnapshot,
 	SnapshotInfo,
 } from "Tools/ExportSnapshot/exportBoardSnapshot";
 import { LinkTo } from "../LinkTo/LinkTo";
 import { translateElementBy } from "HTMLRender";
 import { DefaultFrameData, FRAME_TITLE_COLOR, FrameData } from "./FrameData";
 import { DocumentFactory } from "api/DocumentFactory";
 
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 const defaultFrameData = new DefaultFrameData();
 
-export class Frame implements Geometry {
+export class Frame extends BaseItem {
 	readonly itemType = "Frame";
 	parent = "Board";
 	readonly transformation: Transformation;
 	readonly subject = new Subject<Frame>();
 	private textContainer: Mbr;
 	private path: Path;
 	private children: string[] = [];
 	private mbr: Mbr = new Mbr();
 	readonly linkTo: LinkTo;
 	readonly text: RichText;
 	private canChangeRatio = true;
 	newShape: FrameType | null = null;
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		private getItemById: (id: string) => Item | undefined,
-		private id = "",
+		id = "",
 		private name = "",
 		private shapeType = defaultFrameData.shapeType,
-		private backgroundColor = defaultFrameData.backgroundColor,
-		private backgroundOpacity = defaultFrameData.backgroundOpacity,
-		private borderColor = defaultFrameData.borderColor,
-		private borderOpacity = defaultFrameData.borderOpacity,
-		private borderStyle = defaultFrameData.borderStyle,
-		private borderWidth = defaultFrameData.borderWidth,
+		public backgroundColor = defaultFrameData.backgroundColor,
+		public backgroundOpacity = defaultFrameData.backgroundOpacity,
+		public borderColor = defaultFrameData.borderColor,
+		public borderOpacity = defaultFrameData.borderOpacity,
+		public borderStyle = defaultFrameData.borderStyle,
+		public borderWidth = defaultFrameData.borderWidth,
 	) {
+		super(board, id);
 		this.textContainer = Frames[this.shapeType].textBounds.copy();
 		this.path = Frames[this.shapeType].path.copy();
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 
 		this.text = new RichText(
 			board,
 			this.textContainer,
 			this.id,
 			this.transformation,
diff a/src/Items/Connector/Connector.ts b/src/Items/Connector/Connector.ts	(rejected hunks)
@@ -26,20 +26,21 @@ import { getStartPointer, getEndPointer } from "./Pointers/index";
 import { ConnectorPointerStyle, Pointer } from "./Pointers/Pointers";
 import { LinkTo } from "../LinkTo/LinkTo";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 } from "HTMLRender";
 import { DocumentFactory } from "api/DocumentFactory";
 import { ConnectorAnchorColors } from "./types";
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 const { i18n } = conf;
 
 export const ConnectorLineStyles = [
 	"straight",
 	"curved",
 	"orthogonal",
 ] as const;
 
 export type ConnectorLineStyle = (typeof ConnectorLineStyles)[number];
 
@@ -59,49 +60,50 @@ export const CONNECTOR_ANCHOR_COLOR: ConnectorAnchorColors = {
 	snapBackground: "rgba(0,0,0,0)",
 	anchorBorder: "rgb(147, 175, 246)",
 	anchorBackground: "rgb(255, 255, 255)",
 	anchorHighlight: "rgb(255, 255, 255)",
 	pointBorder: "rgb(147, 175, 246)",
 	pointBackground: "rgb(147, 175, 246)",
 };
 
 export const CONNECTOR_ANCHOR_TYPE = "rect";
 export const CONNECTOR_LINE_CAP = "round";
-export class Connector {
+export class Connector extends BaseItem {
 	readonly itemType = "Connector";
 	parent = "Board";
-	private id = "";
 	readonly transformation: Transformation;
 	private middlePoint: ControlPoint | null = new BoardPoint();
 	private lineColor: string;
 	readonly linkTo: LinkTo;
 	private lineWidth: ConnectionLineWidth;
-	private borderStyle: BorderStyle;
+	borderStyle: BorderStyle;
 	readonly subject = new Subject<Connector>();
 	lines = new Path([new Line(new Point(), new Point())]);
 	startPointer: Pointer;
 	endPointer: Pointer;
 	animationFrameId?: number;
 	readonly text: RichText;
 	transformationRenderBlock?: boolean = undefined;
 	private optionalFindItemFn?: FindItemFn;
 	constructor(
-		private board: Board,
+		board: Board,
 		private startPoint: ControlPoint = new BoardPoint(),
 		private endPoint: ControlPoint = new BoardPoint(),
 		private lineStyle: ConnectorLineStyle = "straight",
 		private startPointerStyle: ConnectorPointerStyle = "None",
 		private endPointerStyle: ConnectorPointerStyle = DEFAULT_END_POINTER,
 		lineColor?: string,
 		lineWidth?: ConnectionLineWidth,
 		strokeStyle?: BorderStyle,
+		id = "",
 	) {
+		super(board, id);
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 		this.lineColor = lineColor ?? CONNECTOR_COLOR;
 		this.lineWidth = lineWidth ?? CONNECTOR_LINE_WIDTH;
 		this.borderStyle = strokeStyle ?? CONNECTOR_BORDER_STYLE;
 		this.text = new RichText(
 			board,
 			this.getMbr(),
 			this.id,
 			new Transformation(),
diff a/src/Items/Sticker/Sticker.ts b/src/Items/Sticker/Sticker.ts	(rejected hunks)
@@ -22,20 +22,21 @@ import { LinkTo } from "../LinkTo/LinkTo";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender";
 import { SessionStorage } from "App/SessionStorage";
 import { Board } from "Board";
 import { DocumentFactory } from "api/DocumentFactory";
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export const stickerColors = {
 	Purple: "rgb(233, 208, 255)",
 	Pink: "rgb(255, 209, 211)",
 	"Sky Blue": "rgb(206, 228, 255)",
 	Blue: "rgb(205, 250, 255)",
 	Green: "rgb(203, 232, 150)",
 	"Light Green": "rgb(180, 241, 198)",
 	Orange: "rgb(255, 180, 126)",
 	Yellow: "rgb(255, 235, 163)",
@@ -67,36 +68,37 @@ export const StickerShape = {
 		new Point(width / 2, height),
 		new Point(0, height / 2),
 	],
 	DEFAULTS: [width, height],
 };
 
 const defaultStickerData = new StickerData();
 const _hypotenuse = Math.sqrt(height * height + width * width);
 const _relation = width / height;
 
-export class Sticker implements Geometry {
+export class Sticker extends BaseItem {
 	parent = "Board";
 	readonly itemType = "Sticker";
 	readonly transformation: Transformation;
 	readonly linkTo: LinkTo;
 	private stickerPath = StickerShape.stickerPath.copy();
 	private textContainer = StickerShape.textBounds.copy();
 	text: RichText;
 	readonly subject = new Subject<Sticker>();
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
-		private id = "",
-		private backgroundColor = defaultStickerData.backgroundColor,
+		board: Board,
+		id = "",
+		public backgroundColor = defaultStickerData.backgroundColor,
 	) {
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.text = new RichText(
 			board,
 			this.textContainer,
 			this.id,
 			this.transformation,
 			this.linkTo,
 			"\u00A0",
 			false,
diff a/src/Items/Drawing/Drawing.ts b/src/Items/Drawing/Drawing.ts	(rejected hunks)
@@ -2,62 +2,62 @@ import { Events, Operation } from "Events";
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
 import { Line } from "../Line";
 import { Mbr } from "../Mbr";
 import { BorderStyle, BorderWidth, Path, scalePatterns } from "../Path";
 import { Point } from "../Point";
 import { Transformation } from "../Transformation";
 import { DrawingCommand } from "./DrawingCommand";
 import { DrawingOperation } from "./DrawingOperation";
 import { TransformationData } from "../Transformation/TransformationData";
-import { Geometry } from "../Geometry";
 import { isSafari } from "App/isSafari";
 import { LinkTo } from "../LinkTo/LinkTo";
 import {
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender/HTMLRender";
 import { DocumentFactory } from "api/DocumentFactory";
 import { conf } from "Settings";
 import { Board } from "Board";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export interface DrawingData {
 	itemType: "Drawing";
 	points: { x: number; y: number }[];
 	transformation: TransformationData;
 	strokeStyle: string;
 	strokeWidth: number;
 	linkTo?: string;
 }
 
-export class Drawing extends Mbr implements Geometry {
+export class Drawing extends BaseItem {
 	readonly itemType = "Drawing";
 	parent = "Board";
 	readonly transformation: Transformation;
 	private path2d = new conf.path2DFactory();
 	readonly subject = new Subject<Drawing>();
 	untransformedMbr = new Mbr();
 	private lines: Line[] = [];
 	readonly linkTo: LinkTo;
 	strokeWidth: BorderWidth = 1;
 	borderStyle: BorderStyle = "solid";
 	private linePattern = scalePatterns(this.strokeWidth)[this.borderStyle];
 	private borderOpacity = 1;
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		public points: Point[],
 		private events?: Events,
-		private id = "",
+		id = "",
 	) {
-		super();
+		super(board, id);
 		this.transformation = new Transformation(id, events);
 		this.linkTo = new LinkTo(this.id, this.events);
 		this.transformation.subject.subscribe(() => {
 			this.updateMbr();
 			this.updateLines();
 			this.subject.publish(this);
 		});
 		this.linkTo.subject.subscribe(() => {
 			this.updateMbr();
 			this.updateLines();
diff a/src/Items/Audio/index.ts b/src/Items/Audio/index.ts	(rejected hunks)
@@ -1,2 +1,2 @@
 export { AudioItem, AudioItemData } from "./Audio.ts";
-export { uploadAudio } from "./uploadAudio.ts";
+// export { uploadAudio } from "./uploadAudio.ts";
diff a/src/Items/Audio/Audio.ts b/src/Items/Audio/Audio.ts	(rejected hunks)
@@ -1,71 +1,71 @@
 import { Events, Operation } from "Events";
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
-import { Mbr } from "../Mbr";
 import { Transformation } from "../Transformation";
 import { TransformationData } from "../Transformation/TransformationData";
 import { Board } from "Board";
 import { LinkTo } from "../LinkTo/LinkTo";
 import { DocumentFactory } from "api/DocumentFactory";
 import { Path } from "../Path";
 import { Point } from "Items/Point/Point";
 import { Line } from "Items/Line/Line";
 import { conf } from "Settings";
 import { AudioCommand } from "Items/Audio/AudioCommand";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export interface AudioItemData {
 	itemType: "Audio";
 	url: string;
 	transformation: TransformationData;
 	isStorageUrl: boolean;
 	extension?: string;
 }
 
-export class AudioItem extends Mbr {
+export class AudioItem extends BaseItem {
 	readonly itemType = "Audio";
 	parent = "Board";
 	readonly transformation: Transformation;
 	readonly linkTo: LinkTo;
 	readonly subject = new Subject<AudioItem>();
 	loadCallbacks: ((audio: AudioItem) => void)[] = [];
 	beforeLoadCallbacks: ((audio: AudioItem) => void)[] = [];
 	transformationRenderBlock?: boolean = undefined;
 	private url = "";
-	board: Board;
 	private isPlaying = false;
 	private currentTime = 0;
 	private isStorageUrl = true;
 
 	constructor(
 		board: Board,
 		isStorageUrl: boolean,
 		url?: string,
 		private events?: Events,
-		private id = "",
+		id = "",
 		private extension?: string,
 	) {
-		super();
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, events);
 		this.board = board;
 		this.isStorageUrl = isStorageUrl;
 		if (url) {
 			this.applyUrl(url);
 		}
 		this.transformation = new Transformation(id, events);
 		this.linkTo.subject.subscribe(() => {
 			this.updateMbr();
 			this.subject.publish(this);
 		});
 		this.transformation.subject.subscribe(this.onTransform);
 		this.right = this.left + conf.AUDIO_DIMENSIONS.width;
 		this.bottom = this.top + conf.AUDIO_DIMENSIONS.height;
+		this.shouldUseCustomRender = true;
 	}
 
 	setCurrentTime(time: number) {
 		this.currentTime = time;
 	}
 
 	getCurrentTime() {
 		return this.currentTime;
 	}
 
diff a/src/Items/Shape/Shape.ts b/src/Items/Shape/Shape.ts	(rejected hunks)
@@ -9,70 +9,70 @@ import {
 	TransformationOperation,
 	Connector,
 } from "..";
 import { BasicShapes } from "./Basic";
 import { ShapeType } from "./index";
 import { BorderStyle, BorderWidth, LinePatterns } from "../Path";
 import { Subject } from "shared/Subject";
 import { RichText } from "../RichText";
 import { ShapeOperation } from "./ShapeOperation";
 import { DefaultShapeData, ShapeData } from "./ShapeData";
-import { Geometry } from "../Geometry";
 import { DrawingContext } from "../DrawingContext";
 import { Operation } from "Events";
 import { ShapeCommand } from "./ShapeCommand";
 import { GeometricNormal } from "../GeometricNormal";
 import { ResizeType } from "../../Selection/Transformer/TransformerHelpers/getResizeType.ts";
 import { getResize } from "../../Selection/Transformer/TransformerHelpers/getResizeMatrix.ts";
 import { tempStorage } from "App/SessionStorage";
 import { LinkTo } from "../LinkTo/LinkTo";
 import { BPMN } from "./BPMN";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender";
 import { Board } from "Board";
 import { FixedPoint } from "Items/Connector";
 import { toRelativePoint } from "Items/Connector/ControlPoint";
 import { DocumentFactory } from "api/DocumentFactory";
 import { conf } from "Settings";
-import { handleUpdate } from "./handleUpdate";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 const defaultShapeData = new DefaultShapeData();
 
 export const Shapes = { ...BasicShapes, ...BPMN };
 
-export class Shape implements Geometry {
+export class Shape extends BaseItem {
 	readonly itemType = "Shape";
 	parent = "Board";
 	readonly transformation: Transformation;
 	private path: Path | Paths;
 	private textContainer: Mbr;
 	readonly text: RichText;
 	readonly linkTo: LinkTo;
 	readonly subject = new Subject<Shape>();
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
-		private id = "",
-		private shapeType = defaultShapeData.shapeType,
-		private backgroundColor = defaultShapeData.backgroundColor,
-		private backgroundOpacity = defaultShapeData.backgroundOpacity,
-		private borderColor = defaultShapeData.borderColor,
-		private borderOpacity = defaultShapeData.borderOpacity,
-		private borderStyle = defaultShapeData.borderStyle,
-		private borderWidth = defaultShapeData.borderWidth,
+		board: Board,
+		id = "",
+		public shapeType = defaultShapeData.shapeType,
+		public backgroundColor = defaultShapeData.backgroundColor,
+		public backgroundOpacity = defaultShapeData.backgroundOpacity,
+		public borderColor = defaultShapeData.borderColor,
+		public borderOpacity = defaultShapeData.borderOpacity,
+		public borderStyle = defaultShapeData.borderStyle,
+		public borderWidth = defaultShapeData.borderWidth,
 		private mbr = Shapes[shapeType].path.getMbr().copy(),
 	) {
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, this.board.events);
 		this.transformation = new Transformation(this.id, this.board.events);
 		this.path = Shapes[this.shapeType].path.copy();
 		this.textContainer = Shapes[this.shapeType].textBounds.copy();
 		this.text = new RichText(
 			board,
 			this.textContainer,
 			this.id,
 			this.transformation,
 			this.linkTo,
diff a/src/Items/Video/Video.ts b/src/Items/Video/Video.ts	(rejected hunks)
@@ -6,20 +6,21 @@ import { Transformation } from "../Transformation";
 import { TransformationData } from "../Transformation/TransformationData";
 import { Board } from "Board";
 import { LinkTo } from "../LinkTo/LinkTo";
 import { DocumentFactory } from "api/DocumentFactory";
 import { Paths, Path } from "../Path";
 import { VideoCommand } from "Items/Video/VideoCommand";
 import { Point } from "Items/Point/Point";
 import { Line } from "Items/Line/Line";
 import { conf } from "Settings";
 import { Placeholder } from "Items/Placeholder/Placeholder";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export interface VideoItemData {
 	itemType: "Video";
 	url?: string;
 	videoDimension: Dimension;
 	transformation: TransformationData;
 	isStorageUrl: boolean;
 	previewUrl?: string;
 	extension: string;
 }
@@ -60,48 +61,47 @@ export const createPlaceholderImage = (
 		const iconY = (height - iconSize) / 2;
 
 		ctx.drawImage(videoIcon, iconX, iconY, iconSize * 1.375, iconSize);
 	}
 
 	const image = new Image();
 	image.src = canvas.toDataURL();
 	return image;
 };
 
-export class VideoItem extends Mbr {
+export class VideoItem extends BaseItem {
 	readonly itemType = "Video";
 	parent = "Board";
 	preview: HTMLImageElement;
 	readonly transformation: Transformation;
 	readonly linkTo: LinkTo;
 	readonly subject = new Subject<VideoItem>();
 	loadCallbacks: ((video: VideoItem) => void)[] = [];
 	beforeLoadCallbacks: ((video: VideoItem) => void)[] = [];
 	transformationRenderBlock?: boolean = undefined;
 	private url = "";
 	private previewUrl = "";
 	private isStorageUrl = false;
 	videoDimension: Dimension;
 	board: Board;
-	private isPlaying = false;
 	private shouldShowControls = false;
 	private playBtnMbr: Mbr = new Mbr();
 	private currentTime = 0;
 
 	constructor(
 		{ url, videoDimension, previewUrl }: VideoConstructorData,
 		board: Board,
 		private events?: Events,
-		private id = "",
+		id = "",
 		private extension: string = "mp4",
 	) {
-		super();
+		super(board, id);
 		this.isStorageUrl = !conf.getYouTubeId(url);
 		this.preview = createPlaceholderImage(
 			videoDimension.width,
 			videoDimension.height,
 		);
 		this.linkTo = new LinkTo(this.id, events);
 		this.board = board;
 		// img storage link or youtube preview url
 		if (previewUrl) {
 			this.previewUrl = previewUrl;
@@ -165,28 +165,24 @@ export class VideoItem extends Mbr {
 	}: {
 		previewUrl?: string;
 		url?: string;
 	}): void {
 		this.previewUrl = previewUrl;
 		this.setPreview(this.preview, previewUrl);
 		this.setUrl(url);
 	}
 
 	setIsPlaying(isPlaying: boolean) {
-		this.isPlaying = isPlaying;
+		this.shouldUseCustomRender = isPlaying;
 		this.subject.publish(this);
 	}
 
-	getIsPlaying() {
-		return this.isPlaying;
-	}
-
 	setShouldShowControls(shouldShowControls: boolean) {
 		this.shouldShowControls = shouldShowControls;
 		this.subject.publish(this);
 	}
 
 	getShouldShowControls() {
 		return this.shouldShowControls;
 	}
 
 	getPlayBtnMbr() {
@@ -277,21 +273,21 @@ export class VideoItem extends Mbr {
 			this.right - this.getWidth() / 2 + scaledPlayBtn / 2,
 			this.bottom - this.getHeight() / 2 + scaledPlayBtn / 2,
 		);
 	}
 
 	render(context: DrawingContext): void {
 		if (this.transformationRenderBlock || !this.preview.complete) {
 			return;
 		}
 		const ctx = context.ctx;
-		if (this.isPlaying) {
+		if (this.shouldUseCustomRender) {
 			ctx.save();
 			ctx.globalCompositeOperation = "destination-out";
 			ctx.fillRect(
 				this.left,
 				this.top,
 				this.getWidth(),
 				this.getHeight(),
 			);
 			ctx.restore();
 			return;
diff a/src/Items/Video/index.ts b/src/Items/Video/index.ts	(rejected hunks)
@@ -1,2 +1,2 @@
 export { VideoItem, VideoItemData, VideoConstructorData } from "./Video.ts";
-export { uploadVideo } from "./uploadVideo.ts";
+// export { uploadVideo } from "../../../shared/api/media/uploadVideo.ts";
diff a/src/Items/Group/Group.ts b/src/Items/Group/Group.ts	(rejected hunks)
@@ -1,52 +1,58 @@
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
 import { TransformationData } from "../Transformation/TransformationData";
 import { GroupOperation } from "./GroupOperation";
 import { GroupCommand } from "./GroupCommand";
 import { Events, Operation } from "Events";
 import { Mbr, Line, Point, Transformation, Item } from "..";
 import { Board } from "Board";
 import { LinkTo } from "../LinkTo/LinkTo";
+import { BaseItem } from "Items/BaseItem/BaseItem";
+import { DocumentFactory } from "api/DocumentFactory";
 
 export interface GroupData {
 	readonly itemType: "Group";
 	children: string[];
 	transformation: TransformationData;
 }
 
-export class Group extends Mbr {
+export class Group extends BaseItem {
 	readonly linkTo: LinkTo;
 	readonly itemType = "Group";
 	parent = "Board";
 	readonly transformation: Transformation;
 	readonly subject = new Subject<Group>();
 	private mbr: Mbr = new Mbr();
 	transformationRenderBlock?: boolean = undefined;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		private events?: Events,
 		private children: string[] = [],
-		private id = "",
+		id = "",
 	) {
-		super();
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, this.events);
 		this.transformation = new Transformation(this.id, this.events);
 		this.children = children;
 
 		this.transformation.subject.subscribe(() => {
 			this.updateMbr();
 			this.subject.publish(this);
 		});
 	}
 
+	isClosed(): boolean {
+		return false;
+	}
+
 	getRichText(): null {
 		return null;
 	}
 
 	addChild(childId: string): void {
 		this.emit({
 			class: "Group",
 			method: "addChild",
 			item: [this.getId()],
 			childId,
diff a/src/Items/Image/Image.ts b/src/Items/Image/Image.ts	(rejected hunks)
@@ -1,31 +1,31 @@
 import { Events, Operation } from "Events";
 import { Subject } from "shared/Subject";
 import { DrawingContext } from "../DrawingContext";
 import { Line } from "../Line";
-import { Mbr } from "../Mbr";
 import { Path, Paths } from "../Path";
 import { Point } from "../Point";
 import { Transformation } from "../Transformation";
 import { TransformationData } from "../Transformation/TransformationData";
 import { Placeholder } from "../Placeholder";
 import { Board } from "Board";
 import { LinkTo } from "../LinkTo/LinkTo";
 // import { storageURL } from "./ImageHelpers";
 import {
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender/HTMLRender";
 import { ImageOperation } from "./ImageOperation";
 import { ImageCommand } from "./ImageCommand";
 import { DocumentFactory } from "api/DocumentFactory";
 import { conf } from "Settings";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export interface ImageItemData {
 	itemType: "Image";
 	storageLink: string;
 	imageDimension: Dimension;
 	transformation: TransformationData;
 	linkTo?: string;
 }
 
 export interface Dimension {
@@ -38,21 +38,21 @@ export function getPlaceholderImage(
 	board: Board,
 	imageDimension?: Dimension,
 ): HTMLImageElement {
 	const placeholderCanvas = conf.documentFactory.createElement("canvas");
 	const placeholderContext = placeholderCanvas.getContext(
 		"2d",
 	) as CanvasRenderingContext2D; // this does not fail
 
 	const context = new DrawingContext(board.camera, placeholderContext);
 
-	const placeholder = new Placeholder();
+	const placeholder = new Placeholder(board);
 
 	if (imageDimension) {
 		placeholderCanvas.width = imageDimension.width;
 		placeholderCanvas.height = imageDimension.height;
 
 		placeholder.transformation.scaleTo(
 			imageDimension.width / 100,
 			imageDimension.height / 100,
 		);
 	} else {
@@ -67,41 +67,41 @@ export function getPlaceholderImage(
 	placeholderImage.src = placeholderCanvas.toDataURL();
 	return placeholderImage;
 }
 
 export interface ImageConstructorData {
 	base64?: string;
 	storageLink: string;
 	imageDimension: Dimension;
 }
 
-export class ImageItem extends Mbr {
+export class ImageItem extends BaseItem {
 	readonly itemType = "Image";
 	parent = "Board";
 	image: HTMLImageElement;
 	readonly transformation: Transformation;
 	readonly linkTo: LinkTo;
 	readonly subject = new Subject<ImageItem>();
 	loadCallbacks: ((image: ImageItem) => void)[] = [];
 	beforeLoadCallbacks: ((image: ImageItem) => void)[] = [];
 	transformationRenderBlock?: boolean = undefined;
 	private storageLink: string;
 	imageDimension: Dimension;
 	board: Board;
 
 	constructor(
 		{ base64, storageLink, imageDimension }: ImageConstructorData,
 		board: Board,
 		private events?: Events,
-		private id = "",
+		id = "",
 	) {
-		super();
+		super(board, id);
 		this.linkTo = new LinkTo(this.id, events);
 		this.board = board;
 		this.setStorageLink(storageLink);
 		this.imageDimension = imageDimension;
 		this.transformation = new Transformation(id, events);
 		this.image = new Image();
 		this.image.crossOrigin = "anonymous";
 		this.image.onload = this.onLoad;
 		this.image.onerror = this.onError;
 		if (typeof base64 === "string") {
diff a/src/Items/Item.ts b/src/Items/Item.ts	(rejected hunks)
@@ -7,20 +7,21 @@ import { ImageItem, ImageItemData } from "./Image";
 import { Placeholder, PlaceholderData } from "./Placeholder/Placeholder";
 import { RichText, RichTextData } from "./RichText";
 import { Shape, ShapeData } from "./Shape";
 import { Sticker } from "./Sticker";
 import { StickerData } from "./Sticker/StickerOperation";
 import { Comment, CommentData } from "./Comment";
 import { AINode } from "Items/AINode/AINode";
 import { AINodeData } from "Items/AINode/AINodeData";
 import { VideoItem, VideoItemData } from "Items/Video/Video";
 import { AudioItem, AudioItemData } from "Items/Audio/Audio";
+import { SerializedItemData } from "Items/BaseItem/BaseItem";
 
 export type Item =
 	| RichText
 	| Shape
 	| Connector
 	| ImageItem
 	| Drawing
 	| Sticker
 	| Frame
 	| Placeholder
@@ -37,11 +38,12 @@ export type ItemData =
 	| ConnectorData
 	| ImageItemData
 	| DrawingData
 	| StickerData
 	| FrameData
 	| PlaceholderData
 	| CommentData
 	| GroupData
 	| AINodeData
 	| VideoItemData
-	| AudioItemData;
+	| AudioItemData
+	| SerializedItemData;
diff a/src/Items/AINode/AINode.ts b/src/Items/AINode/AINode.ts	(rejected hunks)
@@ -3,69 +3,70 @@ import { DocumentFactory } from "api/DocumentFactory";
 import { Operation } from "Events/EventsOperations";
 import {
 	positionRelatively,
 	resetElementScale,
 	scaleElementBy,
 	translateElementBy,
 } from "HTMLRender/HTMLRender";
 import { AINodeData, createNodePath } from "Items/AINode/AINodeData";
 import { DrawingContext } from "Items/DrawingContext";
 import { GeometricNormal } from "Items/GeometricNormal";
-import { Geometry } from "Items/Geometry";
 import { Line } from "Items/Line/Line";
 import { LinkTo } from "Items/LinkTo/LinkTo";
 import { Mbr } from "Items/Mbr/Mbr";
 import { LinePatterns, Path } from "Items/Path/Path";
 import { Paths } from "Items/Path/Paths";
 import { Point } from "Items/Point/Point";
 import { RichText } from "Items/RichText/RichText";
 import { Matrix } from "Items/Transformation/Matrix";
 import { Transformation } from "Items/Transformation/Transformation";
 import { TransformationOperation } from "Items/Transformation/TransformationOperations";
 import { conf } from "Settings";
 import { Subject } from "shared/Subject";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 export const CONTEXT_NODE_HIGHLIGHT_COLOR = "rgba(183, 138, 240, 1)";
 const BUTTON_SIZE = 20;
 export type ThreadDirection = 0 | 1 | 2 | 3;
 // TODO FIX node
 // const arrowIcon = new Image();
 const ICON_SRC =
 	"data:image/svg+xml;charset=utf-8,%3Csvg id='AIChatSendArrow' viewBox='0 0 21 21' xmlns='http://www.w3.org/2000/svg' fill='url(%23paint0_linear_7542_32550)'%3E%3Cpath d='M0.946815 7.31455C0.424815 7.14055 0.419815 6.85955 0.956815 6.68055L20.0438 0.318552C20.5728 0.142552 20.8758 0.438552 20.7278 0.956552L15.2738 20.0426C15.1238 20.5716 14.8188 20.5896 14.5948 20.0876L11.0008 11.9996L17.0008 3.99955L9.00081 9.99955L0.946815 7.31455Z'/%3E%3Cdefs%3E%3ClinearGradient id='paint0_linear_7542_32550' x1='10.66' y1='0.267578' x2='10.66' y2='20.452' gradientUnits='userSpaceOnUse'%3E%3Cstop stop-color='%23CD4FF2'/%3E%3Cstop offset='1' stop-color='%235F4AFF'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E";
 // arrowIcon.src = ICON_SRC;
 
-export class AINode implements Geometry {
+export class AINode extends BaseItem {
 	readonly itemType = "AINode";
 	parent = "Board";
 	readonly transformation: Transformation;
 	readonly text: RichText;
 	readonly linkTo: LinkTo;
 	private path: Paths | Path;
 	readonly subject = new Subject<AINode>();
 	private parentNodeId?: string;
 	private isUserRequest: boolean;
 	private contextItems: string[] = [];
 	private threadDirection: ThreadDirection = 3;
 	private contextRange = 5;
 	transformationRenderBlock?: boolean = undefined;
 	private buttonMbr: Mbr = new Mbr();
 	private buttonIcon: HTMLImageElement;
 	prevMbr: Mbr | null = null;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		isUserRequest = false,
 		parentNodeId?: string,
 		contextItems: string[] = [],
 		threadDirection?: ThreadDirection,
-		private id = "",
+		id = "",
 	) {
+		super(board, id);
 		this.buttonIcon = conf.documentFactory.createElement(
 			"img",
 		) as HTMLImageElement;
 		this.buttonIcon.src = ICON_SRC;
 		this.contextItems = contextItems;
 		this.isUserRequest = isUserRequest;
 		this.parentNodeId = parentNodeId;
 		if (threadDirection || threadDirection === 0) {
 			this.threadDirection = threadDirection;
 		}
diff a/src/Items/RichText/EditorContainer.ts b/src/Items/RichText/EditorContainer.ts	(rejected hunks)
@@ -1,71 +1,49 @@
-import { getParagraphWithPassedTextNode } from "Items/RichText/editorHelpers/common/getParagraph";
-import { setNodeStyles } from "Items/RichText/setNodeStyles";
 import { conf, DefaultTextStyles } from "Settings";
-import markdown from "remark-parse";
-import slate from "remark-slate";
 import { Subject } from "shared/Subject";
 import {
 	BaseEditor,
 	BaseSelection,
 	createEditor,
 	Descendant,
 	Editor,
-	Element,
-	Location,
-	Node,
-	Range,
 	Operation as SlateOp,
 	Transforms,
-	Path,
 	Operation,
 } from "slate";
 import { HistoryEditor, withHistory } from "slate-history";
 import { ReactEditor, withReact } from "slate-react";
-import { unified } from "unified";
 import { HorisontalAlignment, VerticalAlignment } from "../Alignment";
-import {
-	BlockNode,
-	BlockType,
-	ListType,
-	ListTypes,
-	ParagraphNode,
-} from "./Editor/BlockNode";
+import { BlockNode, ListType, ParagraphNode } from "./Editor/BlockNode";
 import { TextNode, TextStyle } from "./Editor/TextNode";
 import { isTextEmpty } from "./editorHelpers/common/isTextEmpty.ts";
 import {
 	RichTextOperation,
-	SelectionMethod,
 	SelectionOp,
 	WholeTextOp,
 } from "./RichTextOperations";
-import { findCommonStrings } from "./utils";
 import { handleListMerge } from "./editorHelpers/lists/handleListMerge.ts";
 import { handleSplitListItem } from "Items/RichText/editorHelpers/lists/handleSplitListItem";
 import { createParagraphNode } from "Items/RichText/editorHelpers/common/createParagraphNode";
 import { withAutoList } from "Items/RichText/editorHelpers/lists/withAutoList";
 import { handleWrapIntoNestedList } from "Items/RichText/editorHelpers/lists/handleWrapIntoNestedList";
 import { toggleListType } from "Items/RichText/editorHelpers/lists/toggleListType";
 import { getListTypeAtSelectionStart } from "Items/RichText/editorHelpers/lists/getListTypeAtSelectionStart";
 import { setLink } from "Items/RichText/editorHelpers/links/setLink";
 import { selectWholeText } from "Items/RichText/editorHelpers/common/selectWholeText";
 import { getSelectionMarks } from "Items/RichText/editorHelpers/common/getSelectionMarks";
 import { clearText } from "Items/RichText/editorHelpers/common/clearText";
 import { hasTextInSelection } from "Items/RichText/editorHelpers/common/hasTextInSelection";
 import { MarkdownProcessor } from "Items/RichText/editorHelpers/markdown/markdownProcessor";
 import { insertCopiedNodes } from "Items/RichText/editorHelpers/selectionOps/insertCopiedNodes";
 import { moveCursorToEndOfTheText } from "Items/RichText/editorHelpers/common/moveCursorToEndOfText";
-import { insertCopiedText } from "Items/RichText/editorHelpers/selectionOps/insertCopiedText";
 import { getFirstSelectionLink } from "Items/RichText/editorHelpers/links/getFirstSelectionLink";
-import { getAllTextNodesInSelection } from "Items/RichText/editorHelpers/common/getAllTextNodesInSelection";
-import { getEachNodeInSelectionStyles } from "Items/RichText/editorHelpers/common/getEachNodeInSelectionStyles";
-import { isBlockActive } from "Items/RichText/editorHelpers/common/isBlockActive";
 import { setSelectionHorisontalAlignment } from "Items/RichText/editorHelpers/selectionOps/setSelectionHorisontalAlignment";
 import { setSelectionFontHighlight } from "Items/RichText/editorHelpers/selectionOps/setSelectionFontHighlight";
 import { setSelectionFontSize } from "Items/RichText/editorHelpers/selectionOps/setSelectionFontSize";
 import { setSelectionFontStyle } from "Items/RichText/editorHelpers/selectionOps/setSelectionFontStyle";
 import { setSelectionFontColor } from "Items/RichText/editorHelpers/selectionOps/setSelectionFontColor";
 
 const { i18n } = conf;
 
 // import { getSlateFragmentAttribute } from "slate-react/dist/utils/dom";
 
diff a/src/Items/RichText/RichText.ts b/src/Items/RichText/RichText.ts	(rejected hunks)
@@ -46,40 +46,41 @@ import {
 	getParagraph,
 	getParagraphWithPassedTextNode,
 } from "./editorHelpers/common/getParagraph.ts";
 import { RichTextOperation } from "./RichTextOperations";
 import { applySelectionFontColor } from "./editorHelpers/selectionOps/applySelectionFontColor.ts";
 import { applySelectionFontSize } from "./editorHelpers/selectionOps/applySelectionFontSize.ts";
 import { getSelectedBlockNode } from "Items/RichText/editorHelpers/common/getSelectedBlockNode";
 import { getSelectionStyles } from "Items/RichText/editorHelpers/common/getSelectionStyles";
 import { setEditorFocus } from "./editorHelpers/common/setEditorFocus.ts";
 import { getAllTextNodesInSelection } from "Items/RichText/editorHelpers/common/getAllTextNodesInSelection";
+import { BaseItem } from "Items/BaseItem/BaseItem";
 
 const { i18n } = conf;
 
 let isEditInProcessValue = false;
 
 export function isEditInProcess(): boolean {
 	return isEditInProcessValue;
 }
 
 export function toggleEdit(value: boolean): void {
 	isEditInProcessValue = value;
 }
 
 let counter = 0;
 
 /**
  * A geometric item to render a rich text on a DrawingContext.
  *
  */
-export class RichText extends Mbr implements Geometry {
+export class RichText extends BaseItem {
 	readonly itemType = "RichText";
 	parent = "Board";
 	readonly subject = new Subject<RichText>();
 	readonly editor: EditorContainer;
 
 	readonly editorTransforms = Transforms;
 	readonly editorEditor = Editor;
 
 	private isContainerSet = false;
 	isRenderEnabled = true;
@@ -95,32 +96,32 @@ export class RichText extends Mbr implements Geometry {
 	lastClickPoint?: Point;
 	initialFontColor?: string;
 	frameMbr?: Mbr;
 	private _onLimitReached: () => void = () => {};
 	private shrinkWidth = false;
 	prevMbr: Mbr | null = null;
 
 	rtCounter = 0;
 
 	constructor(
-		private board: Board,
+		board: Board,
 		public container: Mbr,
-		private id = "",
+		id = "",
 		readonly transformation = new Transformation(id, board.events),
 		linkTo?: LinkTo,
 		public placeholderText = i18n?.t("board.textPlaceholder"),
 		public isInShape = false,
 		private autoSize = false,
 		public insideOf?: ItemType,
 		private initialTextStyles: DefaultTextStyles = conf.DEFAULT_TEXT_STYLES,
 	) {
-		super();
+		super(board, id);
 		counter = counter + 1;
 		this.rtCounter = counter;
 
 		this.linkTo = linkTo || new LinkTo(this.id, this.board.events);
 		let textSizeFromStorage = new SessionStorage().getFontSize(
 			insideOf || "RichText",
 		);
 		if (!textSizeFromStorage || textSizeFromStorage === "auto") {
 			textSizeFromStorage = initialTextStyles.fontSize;
 		}
@@ -241,20 +242,24 @@ export class RichText extends Mbr implements Geometry {
 				this.getFontStyles(),
 				this.getFontColor(),
 				this.isAutosize() ? 14 : this.getFontSize(),
 				this.getFontFamily(),
 				this.getDefaultHorizontalAlignment(),
 				this.placeholderText,
 			);
 		}
 	}
 
+	isClosed(): boolean {
+		return true;
+	}
+
 	getHyperLinkByPointerCoordinates(point: Point) {
 		for (const link of this.layoutNodes.linkPositions) {
 			const { link: hyperLink, left, right, bottom, top } = link;
 			const mbr = new Mbr(left, top, right, bottom);
 			if (this.insideOf === "AINode") {
 				mbr.left += 20;
 				mbr.top += 20;
 				mbr.right += 20;
 				mbr.bottom += 20;
 			}
diff a/src/Tools/Tools.ts b/src/Tools/Tools.ts	(rejected hunks)
@@ -9,20 +9,24 @@ import { AddShape } from "./AddShape";
 import { AddSticker } from "./AddSticker";
 import { AddText } from "./AddText";
 import { BoardTool } from "./BoardTool";
 import { ExportSnapshot } from "./ExportSnapshot/ExportSnapshot";
 import { Navigate } from "./Navigate";
 import { Select } from "./Select";
 import { ToolContext } from "./ToolContext";
 import { Frame, Item, Point } from "Items";
 import { Eraser } from "./Eraser";
 import { AddComment } from "./AddComment";
+import { Tool } from "Tools/Tool";
+import { CustomTool } from "Tools/CustomTool";
+
+export const registeredTools: Record<string, typeof CustomTool> = {};
 
 export class Tools extends ToolContext {
 	readonly subject = new Subject<Tools>();
 	beforeNavigateMode: "navigate" | "select" = "navigate";
 
 	constructor(protected board: Board) {
 		super();
 	}
 
 	setTool(tool: BoardTool): void {
@@ -49,20 +53,50 @@ export class Tools extends ToolContext {
 		if (clearSelection) {
 			this.board.selection.removeAll();
 		}
 		this.publish();
 	}
 
 	getSelect(): Select | undefined {
 		return this.tool instanceof Select ? this.tool : undefined;
 	}
 
+	addRegisteredTool(toolName: string, clearSelection = false): void {
+		if (this.board.getInterfaceType() !== "edit") {
+			this.tool = new Navigate(this.board);
+			return;
+		}
+		if (this.getAddRegisteredTool(toolName) && !isIframe()) {
+			this.cancel();
+		} else {
+			const tool = registeredTools[toolName];
+			if (!tool) {
+				console.warn(`Tool with name "${toolName}" not found`);
+				return;
+			}
+
+			this.tool = new tool(this.board, toolName);
+			if (clearSelection) {
+				this.board.selection.removeAll();
+			}
+		}
+		this.publish();
+	}
+
+	getAddRegisteredTool(toolName: string): Tool | undefined {
+		const targetTool = registeredTools[toolName];
+		return this.tool instanceof CustomTool &&
+			this.tool.name === targetTool.name
+			? this.tool
+			: undefined;
+	}
+
 	addSticker(clearSelection = false): void {
 		if (this.board.getInterfaceType() !== "edit") {
 			this.tool = new Navigate(this.board);
 			return;
 		}
 		if (this.getAddSticker() && !isIframe()) {
 			this.cancel();
 		} else {
 			this.tool = new AddSticker(this.board);
 			if (clearSelection) {
